import { createLogger, removeTrailingSlashes, isNullish } from '@sap-cloud-sdk/util';
import { a as BTPLLMContext, B as BTPLLMError } from './index-924dd70f.mjs';
import axios from 'axios';

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const _OAuthClient = class _OAuthClient {
  /**
   * @param config BTP LLM Configuration
   */
  constructor(config) {
    /**
     * Configuration
     */
    __publicField$2(this, "config");
    /**
     * Logger instance
     */
    __publicField$2(this, "logger");
    /**
     * Axios HTTP Client
     */
    __publicField$2(this, "httpClient");
    this.logger = createLogger("btp-llm-commons:auth");
    this.config = config;
    this.httpClient = axios.create({
      baseURL: removeTrailingSlashes(config.oauthTokenUrl)
    });
  }
  /**
   * Gets a JWT token via Client Credentials flow
   * @param config BTP LLM Configuration
   * @returns JWT token
   */
  static async getTokenClientCredentials(config) {
    if (!this.instance) {
      this.instance = new _OAuthClient(config);
    }
    return this.instance.getAccessToken();
  }
  /**
   * Checks if token is expireds
   * @param token JWT token
   * @returns true if expired else false
   */
  static tokenExpired(token) {
    if (isNullish(token))
      return true;
    try {
      const { exp } = JSON.parse(atob(token.split(".")[1]));
      return Math.floor(Date.now() / 1e3) >= exp;
    } catch (error) {
      return true;
    }
  }
  /**
   * Gets a JWT token via Client Credentials flow
   * @returns JWT token
   */
  async getAccessToken() {
    this.logger.debug(`Feching access-token from ${this.config.oauthTokenUrl}/oauth/token`);
    const token = await this.httpClient.post(
      `/oauth/token`,
      {
        grant_type: "client_credentials",
        client_id: this.config.oauthClientId,
        client_secret: this.config.oauthClientSecret
      },
      {
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        }
      }
    );
    this.logger.debug(`Fetched access-token from ${this.config.oauthTokenUrl}/oauth/token`);
    return token.data.access_token;
  }
};
__publicField$2(_OAuthClient, "instance");
let OAuthClient = _OAuthClient;

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class BTPLLMHttpClient {
  /**
   * @param config BTP LLM Configuration
   */
  constructor(config) {
    /**
     * Configuration of the BTP LLM Proxy Client
     */
    __publicField$1(this, "config");
    /**
     * Axios HTTP Client
     */
    __publicField$1(this, "httpClient");
    /**
     * Cached JWT access token
     */
    __publicField$1(this, "accessToken");
    this.config = config;
    this.httpClient = axios.create({
      baseURL: removeTrailingSlashes(config.llmProxyBaseUrl)
    });
    this.httpClient.interceptors.request.use(this.injectAccessToken.bind(this));
  }
  /**
   * Injects JWT token into Bearer `Authorization` header
   */
  async injectAccessToken(reqConfig) {
    if (OAuthClient.tokenExpired(this.accessToken)) {
      this.accessToken = await OAuthClient.getTokenClientCredentials(this.config);
    }
    reqConfig.headers.Authorization = `Bearer ${this.accessToken}`;
    return reqConfig;
  }
  /**
   * Get HTTP Request
   *
   * @param path The API URL path
   * @param requestConfig Axios Request Configuration
   *
   * @see https://axios-http.com/docs/req_config
   * @see https://axios-http.com/docs/cancellation
   *
   * @returns HTTP Axios Response
   */
  async get(path, requestConfig) {
    return this.httpClient.get(path, requestConfig);
  }
  /**
   * Post HTTP Request
   *
   * @param path The API URL path
   * @param data the payload to send to the API
   * @param requestConfig Axios Request Configuration
   *
   * @see https://axios-http.com/docs/req_config
   * @see https://axios-http.com/docs/cancellation
   *
   * @returns HTTP Axios Response
   */
  async post(path, data, requestConfig) {
    return this.httpClient.post(path, data, requestConfig);
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class BaseLLMClient {
  /**
   * @param name LLM Client name
   * @param httpClient HTTP Client
   */
  constructor(name, httpClient) {
    /**
     * Name of the LLM for which the client is for
     */
    __publicField(this, "name");
    /**
     * Logger
     */
    __publicField(this, "logger");
    /**
     * HTTP Client
     */
    __publicField(this, "httpClient");
    this.name = name;
    this.httpClient = httpClient != null ? httpClient : new BTPLLMHttpClient(BTPLLMContext.getConfig());
    this.logger = createLogger(`btp-llm-commons:llm-client:${name}`);
  }
  /**
   *
   * @param path The API URL path
   * @param data the payload to send to the API
   * @param requestConfig Axios Request Configuration
   *
   * @see https://axios-http.com/docs/req_config
   * @see https://axios-http.com/docs/cancellation
   *
   * @returns HTTP Response data as JSON
   * @throws {@link BTPLLMError} in case of HTTP errors
   */
  async request(path, data, requestConfig) {
    try {
      const response = await this.httpClient.post(path, data, requestConfig);
      return response.data;
    } catch (_err) {
      const err = _err;
      if (err.response) {
        const msg = `The request via ${this.name} client got a failed response with status - ${err.response.status} and message - ${JSON.stringify(err.response.data)}`;
        this.logger.error(msg);
        throw new BTPLLMError(msg, err);
      } else if (err.request) {
        const msg = `The request via ${this.name} client was sent but no response received - ${err.message}`;
        this.logger.error(msg);
        throw new BTPLLMError(msg, err);
      } else {
        const msg = `Unknown error happened - ${err.message}`;
        this.logger.error(msg);
        throw new BTPLLMError(msg, err);
      }
    }
  }
  /**
   * Gets the Text Completion response
   *
   * @param data the payload to send to the API
   * @param requestConfig Axios Request Configuration
   *
   * @see https://axios-http.com/docs/req_config
   * @see https://axios-http.com/docs/cancellation
   *
   * @returns HTTP Response data as JSON
   * @throws {@link BTPLLMError} in case of HTTP errors
   */
  async getTextCompletionResponse(data, requestConfig) {
    return this.request(`/api/v1/completions`, data, requestConfig);
  }
  /**
   * Gets the Text Embedding response
   *
   * @param data the payload to send to the API
   * @param requestConfig Axios Request Configuration
   *
   * @see https://axios-http.com/docs/req_config
   * @see https://axios-http.com/docs/cancellation
   *
   * @returns HTTP Response data as JSON
   * @throws {@link BTPLLMError} in case of HTTP errors
   */
  async getEmbeddingResponse(data, requestConfig) {
    return this.request(`/api/v1/embeddings`, data, requestConfig);
  }
}

export { BaseLLMClient as B };
