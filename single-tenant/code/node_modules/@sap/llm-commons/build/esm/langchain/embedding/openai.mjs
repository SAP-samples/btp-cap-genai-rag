import { OpenAIEmbeddings } from 'langchain/embeddings/openai';
import { BTPOpenAIGPTClient } from '../../client/openai.mjs';
import { c as chunkArray } from '../../utils-8f77ab42.mjs';
import '../../base-540b2ebe.mjs';
import '@sap-cloud-sdk/util';
import '../../index-924dd70f.mjs';
import '@sap/xsenv';
import 'fs';
import 'util';
import 'axios';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => {
  if (symbol = Symbol[name])
    return symbol;
  throw Error("Symbol." + name + " is not defined");
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
class BTPOpenAIGPTEmbedding extends OpenAIEmbeddings {
  constructor(fields) {
    var _a;
    super(__spreadProps(__spreadValues({}, fields), { openAIApiKey: "dummy" }));
    __publicField(this, "btpOpenAIClient");
    __publicField(this, "deployment_id");
    this.deployment_id = (_a = fields == null ? void 0 : fields.deployment_id) != null ? _a : "text-embedding-ada-002-v2";
    this.btpOpenAIClient = new BTPOpenAIGPTClient();
  }
  async embedDocuments(documents) {
    const chunkedPrompts = chunkArray(
      this.stripNewLines ? documents.map((t) => t.replace(/\n/g, " ")) : documents,
      this.batchSize
    );
    const embeddings = [];
    try {
      for (var iter = __forAwait(chunkedPrompts), more, temp, error; more = !(temp = await iter.next()).done; more = false) {
        const promptChunk = temp.value;
        const resArr = await this.createEmbedding(promptChunk);
        resArr.forEach((res) => embeddings.push(res.embedding));
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && await temp.call(iter);
      } finally {
        if (error)
          throw error[0];
      }
    }
    return embeddings;
  }
  async embedQuery(query) {
    const resArr = await this.createEmbedding(this.stripNewLines ? query.replace(/\n/g, " ") : query);
    return resArr[0].embedding;
  }
  async createEmbedding(query) {
    const res = await this.caller.callWithOptions(
      {},
      () => this.btpOpenAIClient.createEmbedding({
        deployment_id: this.deployment_id,
        input: query
      })
    );
    return res.data;
  }
}
const BTPOpenAIEmbedding = BTPOpenAIGPTEmbedding;

export { BTPOpenAIEmbedding, BTPOpenAIGPTEmbedding };
